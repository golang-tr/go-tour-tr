Metodlar ve arayüzler
Bu bölüm, metodlar ("method"), arayüzler ("interface"), nesneleri ("object") ve nesnelerin davranış biçimlerini tanımlayan yapıları kapsıyor.

Go Yazarları Sunar
http://golang.org

* Metodlar

Go dilinde sınıf ("class") yapısı bulunmaz. Buna karşın "struct" türleri üzerinde metodlar tanımlayabilirsiniz.

_Metod_alıcısı_ ("method receiver"), `func` anahtar sözcüğü ve metod ismi arasında kendi argüman listesinde bulunur.

.play methods/methods.go

* Metodlar devam

Hatta sadece "struct"larda değil, paketinizde tanımladığınız _herhangi_ bir tür üzerinde de metodlar tanımlayabilirsiniz.

Başka bir paketten aldığınız bir tür ya da temel türler üzerinde metod tanımlayamazsınız.

.play methods/methods-continued.go

* Alıcısı işaretçi olan metodlar

Metodlar adlandırılmış türlerle ya da adlandırılmış bir türü gösteren işaretçilerle ilişkilendirilebilir.

Daha henüz iki `Abs` metodu gördük.  Biri `*Vertex` işaretçi türü, diğeri ise `MyFloat` türü üzerinde tanımlı `Abs` metodları.

İşaretçi alıcısı ("pointer receiver") kullanmamızın iki nedeni vardır. Birincisi, her metod çağrısında değer kopyalamasından kaçınmak (eğer değer türü büyük bir "struct" ise daha verimli); ikincisi, metodun işaret alıcısının gösterdiği değeri değiştirebilmesi.

`*Vertex` yerine `Vertex` 'i alıcı olarak kullanmak için, `Abs` ve `Scale` metodlarının bildirimlerini değiştirmeyi deneyin.

`v` bir `Vertex` ise, `Scale` metodunun hiçbir etkisi yoktur. `Scale`, `v` 'yi değiştirir. `v` işaretçi olmayan bir değer olduğunda, metod onu `Vertex` 'in bir kopyası olarak görür ve asıl değeri değiştiremez.

`Abs` her iki şekilde de çalışır. Yalnızca `v` 'yi okur. Burada asıl değeri okuması (işaretçi vasıtası ile) ve kopyalanmış değeri okuması arasında hiçbir fark yoktur.

.play methods/methods-with-pointer-receivers.go

* Arayüzler

Bir arayüz ("interface") türü bir grup metod tarafından tanımlanır.

Arayüz türünün değeri, o metodları gerçekleyen değerlerden herhangi birine sahip olabilir.

*Not:* Örnek kodun 22. satırında hata mevcut.
`Vertex` (değerin türü) `Abser` türünü karşılamıyor çünkü
`Abs` metodu sadece `*Vertex` (gösterici türü) üzerinde tanımlı.

.play methods/interfaces.go

* Arayüzler devam

Bir tür, arayüz tarafından bildirilen metodları gerçeklemek suretiyle o arayüzü gerçekler.

_Burada_niyetin_açık_şekilde_bildirilmesi_söz_konusu_değildir._

Dolaylı arayüzler ("implicit interfaces") gerçekleme paketlerini, arayüzü tanımlayan paketlerden ayırır: hiçbiri bir diğerine bağlı değildir.

Dolaylı arayüzler, aynı zamanda, arayüzlerin hassas şekilde tanımlanmasını teşvik eder; çünkü bu sayede her gerçeklemeyi bulup yeni bir arayüz ismi ile etiketlemek zorunluluğundan kurtulursunuz.

[[http://golang.org/pkg/io/][Package io]], `Reader` ve `Writer` 'ı otomatik olarak tanımlar; böylece siz tanımlamak zorunda kalmazsınız.

.play methods/interfaces-are-satisfied-implicitly.go

* Stringer

Sıklıkla rastlanan arayüzlerden biri de [[//golang.org/pkg/fmt/][`fmt`]] paketinde tanımlı [[//golang.org/pkg/fmt/#Stringer][`Stringer`]]dır.

	type Stringer struct {
		String() string
	}

`Stringer`  kendini bir dizgi ("string") olarak tanımlayan bir türdür. `fmt` paketi
(ve bir çoğu) değerleri yazdırmak için bu arayüze bakarlar.

.play methods/stringer.go

* Alıştırma: Stringer

`IPAddr` türünün `fmt.Stringer` türünü gerçeklemesini sağlayarak tuttuğu adresi
noktalı ve 4 bölme ayırarak yazmasını sağla.

Örneğin, `IPAddr{1,`2,`3,`4}`, `"1.2.3.4"` şeklinde yazdırılmalı.

.play methods/exercise-stringer.go

* Hatalar

Kendini bir hata dizgisiyle tarif edebilen her şey bir "hata"dır.

`error` türü, `fmt.Stringer` arayüzüne benzer yerleşik bir arayüzdür.

	type error interface {
		Error() string
	}

(`fmt.Stringer` arayüzünde olduğu gibi `fmt` paketindeki çeşitli çıktı rutinleri,
bir `error` çıktısı istendiğinde onu nasıl sunacaklarını otomatik olarak bilir.)

Fonksiyonlar sıklıkla bir `error` değeri döndürür ve fonksiyonu çağıran kod,
hata değerinin `nil` değerine eşit olup olmadığını kontrol ederek hataları yakalamalıdır.

	i, err := strconv.Atoi("42")
	if err != nil {
		fmt.Printf("couldn't convert number: %v\n", err)
	}
	fmt.Println("Converted integer:", i)

nil `error` değeri fonksiyonun başarı ile sonlandığını belirtirken;
nil harici bir `error` değeri fonksiyonun başarısızlıkla sonlandığını belirtir.

.play methods/errors.go

* Alıştırma: Hatalar

Önceki alıştırmalarda kullandığınız `Sqrt` fonksiyonunuzu kopyalayın ve onu bir `error` (hata) değeri döndürecek şekilde düzenleyin.

`Sqrt` fonksiyonunuz negatif bir sayı verildiğinde, tıpkı kompleks sayıları desteklemediğinde yapacağı gibi, nil olmayan bir hata mesajı döndürmelidir.

Yeni bir tür oluşturun

	type ErrNegativeSqrt float64

ve ona

	func (e ErrNegativeSqrt) Error() string

metodunu ekleyerek `error` üretebilecek hale getirin. Örneğin; `ErrNegativeSqrt(-2).Error()` metodunun `"Negatif`sayıların`karekökü`alınamaz:`-2"` döndürmesi gibi.

*Not:* `Error` metodunun içindeki `fmt.Print(e)`'e yapılan bir çağrı, programı sonsuz bir döngüye sokacaktır. `e` değerini öncelikle dönüştürerek bunu önleyebilirsiniz: `fmt.Print(float64(e))`. Neden?

`Sqrt` fonksiyonunuzu, bir negatif sayı verildiğinde `ErrNegativeSqrt` değerini döndürecek biçimde değiştirin.

.play methods/exercise-errors.go

* Okuyucular

`io` paketi veri akışının sonunu okuyan `io.Reader` arayüzünü kapsar.

Go standart kütüphanesi bu çeşit [[http://golang.org/search?q=Read#Global][birçok okuyucu arayüz gerçeklemesine]] sahiptir: dosyalar, ağ bağlantıları, sıkıştırıcılar, şifreler ve diğerleri.

`io.Reader` arayüzü `Read` metoduna sahiptir:

	func (T) Read(b []byte) (n int, err error)

`Read` metodu, kendisine verilen byte dilimi ile veri üretir ve üretilen
verinin kaç byte olduğu ile hata değerini döner. Eğer veri akışı sonlanmışsa
`io.EOF` hatası döner.

Örnek kod bir
[[//golang.org/pkg/strings/#Reader][`strings.Reader`]].
oluşturuyor ve tek seferde 8 bytelık çıktı işliyor.

.play methods/reader.go

* Alıştırma: Okuyucular

Sınırsız ASCII `'A'` karakter akışı sağlayan bir `Reader` türü gerçekleyin.

.play methods/exercise-reader.go

* Alıştırma: Rot13 Okuyucu

En yaygın tasarım desenlerinden biri [[http://golang.org/pkg/io/#Reader][io.Reader]]'ın başka bir `io.Reader` 'ı sarmalayıp, akışı bir şekilde düzenlemesidir.

Örneğin, [[http://golang.org/pkg/compress/gzip/#NewReader][gzip.NewReader]] fonksiyonu bir `io.Reader` alır ("gzip"lenmiş verinin bir parçası) ve onu aynı zamanda `io.Reader` 'ı gerçekleyen (açılmış verini
n bir parçası) bir `*gzip.Reader` 'a döndürür.

[[http://en.wikipedia.org/wiki/ROT13][ROT13]] algoritmasını kullanarak alfabedeki tüm harfleri veri akışını değiştirerek şifreleyen, `io.Reader` 'dan okuyup yine `io.Reader` 'a yazan bir `rot13Reader` gerç
ekleyin.

`rot13Reader` türünü sizin için sunduk. `Read` metodunu gerçekleyerek onu bir `io.Reader` haline getirin.

.play methods/exercise-rot-reader.go

* Web sunucuları

[[http://golang.org/pkg/net/http/][http paketi]] HTTP isteklerine, `http.Handler` 'ı gerçekleyen değerleri kullanarak yanıt verir:

	package http

	type Handler interface {
		ServeHTTP(w ResponseWriter, r *Request)
	}

Bu örnekte `Hello` türü `http.Handler` 'ı gerçekliyor.

Selamlamayı görmek için [[http://localhost:4000/][http://localhost:4000/]] adresini ziyaret edin.

#appengine: *Not:* Bu örnek turumuzun web-tabanlı kullanıcı arayüzünde çalışmayacaktır.
#appengine: Web sunucusu yazmayı denemek için
#appengine: [[http://golang.org/doc/install/][Go'yu yükleyin]].

.play methods/web-servers.go

* Alıştırma: HTTP İşleyicileri (HTTP Handlers)

Aşağıdaki türleri gerçekleyin ve bu türler üzerindeki ServeHTTP metodlarını tanımlayın. Web sunucunuzdaki belirli yolları kontrol edebilmek için bu türleri o yollar ile ilişkilendirin.

	type String string

	type Struct struct {
		Greeting string
		Punct    string
		Who      string
	}

Örneğin, işleyicileri ("handlers") ilgili istekler ile şu şekilde ilişkilendirebiliyor olmalısınız:

	http.Handle("/string", String("I'm a frayed knot."))
	http.Handle("/struct", &Struct{"Hello", ":", "Gophers!"})

#appengine: *Not:* Bu örnek turumuzun web-tabanlı kullanıcı arayüzünde çalışmayacaktır.
#appengine: Web sunucusu yazmayı denemek için
#appengine: [[http://golang.org/doc/install/][Go'yu yükleyin]].

.play methods/exercise-http-handlers.go

* Görüntüler

[[http://golang.org/pkg/image/#Image][image paketi]] `Image` arayüzünü tanımlar:

	package image

	type Image interface {
		ColorModel() color.Model
		Bounds() Rectangle
		At(x, y int) color.Color
	}

*Not*: `Bounds` metodunun `Rectangle` dönüş değeri, aslında
`image` paketinde tanımlandığı üzere,
[[http://golang.org/pkg/image/#Rectangle][`image.Rectangle`]]dır.

(Ayrıntılar için [[http://golang.org/pkg/image/#Image][bu dokümana]] göz atın.)

Ayrıca, `color.Color` ve `color.Model` de birer arayüzdür; fakat öntanımlı `color.RGBA` ve `color.RGBAModel` gerçeklemelerini kullanarak bunu görmezden geleceğiz. Bu arayüz ve türler [[http://golang.org/pkg/image/color/][image/color paketinde]] tanımlanmıştır.

.play methods/images.go

* Alıştırma: Görüntüler

Daha önceden yazdığınız resim üretici hatırladınız mı? Hadi bir tane daha yazalım ama bu defa bir veri dilimi döndürmek yerine `image.Image` gerçeklemesi döndürsün.

Kendi `Image` tipinizi tanımlayın, [[http://golang.org/pkg/image/#Image][gerekli metodları]] gerçekleyin ve `pic.ShowImage` 'i çağırın.

`Bounds`, `image.Rect(0,`0,`w,`h)` gibi bir `image.Rectangle` döndürmelidir.

`ColorModel`, `color.RGBAModel` döndürmeli.

`At` bir renk döndürmelidir; son resim üreticisindeki `v` değeri bu defa `color.RGBA{v,`v,`255,`255}` 'e denk gelmelidir.

.play methods/exercise-images.go

* Tebrikler!

Bu dersin sonuna geldiniz!

Daha neler öğreneceğinizi görmek için [[/list][bölüm listesine]] geri dönün ya da [[javascript:click('.next-page')][bir sonraki derse]] geçin.
